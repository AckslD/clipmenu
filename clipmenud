#!/usr/bin/env bash

: "${CM_DEBUG=0}"
: "${CM_DIR="${XDG_RUNTIME_DIR-"${TMPDIR-/tmp}"}"}"

# Shellcheck is mistaken here, this is used later as lowercase.
# shellcheck disable=SC2153
: "${CM_SELECTIONS=clipboard primary}"

major_version=5
cache_dir=$CM_DIR/clipmenu.$major_version.$USER/
cache_file_prefix=$cache_dir/line_cache

# lock_file is for *one* iteration. session_lock_file is for clipmenud itself.
lock_file=$cache_dir/lock
session_lock_file=$cache_dir/session_lock
lock_timeout=2
has_xdotool=0

# This comes from the environment, so we rely on word splitting.
# shellcheck disable=SC2206
cm_selections=( $CM_SELECTIONS )

_xsel() { xsel --logfile /dev/null "$@"; }
error() { printf 'ERROR: %s\n' "${1?}" >&2; }
info() { printf 'INFO: %s\n' "${1?}"; }
debug() { (( CM_DEBUG )) && printf 'DEBUG: %s\n' "$@" >&2; }
die() {
    error "${2?}"
    exit "${1?}"
}

get_first_line() {
    # We get the first significant line, ignoring lines only with whitespace.
    awk 'NF { printf("%s", substr($0, 0, 300)); exit; }
         END { if (NR > 1) { print " (" NR " lines)" }; }' <<< "${1?}"
}


if [[ $1 == --help ]] || [[ $1 == -h ]]; then
    cat << 'EOF'
clipmenud collects clipboard entries, which can then be selected by clipmenu.

Environment variables:

- $CM_DEBUG: turn on debugging output (default: 0)
- $CM_DIR: specify the base directory to store the cache dir in
  (default: $XDG_RUNTIME_DIR, $TMPDIR, or /tmp)
- $CM_SELECTIONS: space separated list of the selections to manage
  (default: "clipboard primary")
- $CM_IGNORE_WINDOW: disable recording the clipboard in windows where the
  windowname matches the given regex (e.g. a password manager) (default: unset)
EOF
    exit 0
fi

# It's ok that this only applies to the final directory.
# shellcheck disable=SC2174
mkdir -p -m0700 "$cache_dir"

exec {session_lock_fd}> "$session_lock_file"

flock -x -n "$session_lock_fd" ||
    die 2 "Can't lock session file -- is another clipmenud running?"

declare -A last_data
declare -A last_filename
declare -A last_cache_file_output

command -v clipnotify >/dev/null 2>&1 || die 3 "clipnotify binary missing"

command -v xdotool >/dev/null 2>&1 && has_xdotool=1

if [[ $CM_IGNORE_WINDOW ]] && ! (( has_xdotool )); then
    error "CM_IGNORE_WINDOW requires xdotool, which is not installed. Ignoring"
fi

exec {lock_fd}> "$lock_file"

while clipnotify; do
    if [[ $CM_IGNORE_WINDOW ]] && (( has_xdotool )); then
        windowname="$(xdotool getactivewindow getwindowname)"
        if [[ "$windowname" =~ $CM_IGNORE_WINDOW ]]; then
            debug "ignoring clipboard because windowname \"$windowname\" matches \"${CM_IGNORE_WINDOW}\""
            continue
        fi
    fi

    flock -x -w "$lock_timeout" "$lock_fd" || die 1 "Timeout waiting for lock"

    for selection in "${cm_selections[@]}"; do
        cache_file=${cache_file_prefix}_$selection
        data=$(_xsel -o --"$selection"; printf x)

        debug "New potential entry: $data"
        data=${data%x}  # So that trailing newlines are not stripped.

        if [[ $data != *[^[:space:]]* ]]; then
            debug "Skipping as clipboard is only blank"
            continue
        fi

        if [[ ${last_data[$selection]} == "$data" ]]; then
            debug 'Skipping as last selection is the same as this one'
            continue
        fi

        first_line=$(get_first_line "$data")

        debug "New clipboard entry on $selection selection: \"$first_line\""

        cache_file_output="$(date +%s%N) $first_line"
        filename="$cache_dir/$(cksum <<< "$first_line")"

        last_data[$selection]=$data
        last_filename[$selection]=$filename

        # Recover if cache_dir was deleted. It's ok that we only chmod our dir.
        # shellcheck disable=SC2174
        mkdir -p -m0700 "$cache_dir"

        printf '%s' "$data" > "$filename"
        printf '%s\n' "$cache_file_output" >> "$cache_file"

        last_cache_file_output[$selection]=$cache_file_output
    done

    flock -u "$lock_fd"
done
